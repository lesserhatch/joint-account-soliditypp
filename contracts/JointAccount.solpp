// SPDX-License-Identifier: GPL-3.0
pragma soliditypp ^0.8.0;

// Features:
//  * Anyone can create a joint account
//  * Joint account makers can specify who can vote and the approval threshold to move funds
//  * Joint accounts can hold multiple token types
//  * Joint account members can propose a motion to move a specific token type and amount to a specific address
//  * Joint account members can vote to pass the motion or not (not voting counts as rejecting the motion)
//  * If the approval threshold to pass the motion is met, the transfer is executed and then the motion and votes are reset
//  * Motions can be replaced or removed at any time by any joint account member; when this happens, votes are reset.

// UI:
//  * Takes into account "Features" and "Contract Requirements"
//  * Uses Figma or a similar design tool that makes copying color/pixel values easy
//  * Has a logo
//  * Allows users to log in with ViteConnect (i.e. scanning QR code with Vite mobile app)
//  * Is easy for anyone to understand and use - regardless of their experience with crypto.
//  * Be responsive to different screen sizes
//  * Has a light and dark mode with a component to choose between dark/light/system themes
//  * Has a homepage that describes what the dapp is, how to use it, and why it exists.
//  * Has a page that shows all joint accounts your Vite address is a member of
//  * Has a component for proposing/replacing/removing motions to move funds
//  * Has a component for voting on motions
//  * Has a component that shows all a joint account's history (sending/receiving funds, motion pass/reject/replace, etc.)
//  * Additional features are welcome!

contract JointAccountManager {
    uint256 id = 0;
    address[] public accounts;

    function getAccounts() external view returns (address[] memory) {
        return accounts;
    }

    function addJointAccount(address _account) external {
        accounts.push(_account);
    }
}


contract JointAccount {
    event ProposalCreated(
        uint256 id,
        address from,
        address to,
        vitetoken token,
        uint256 amount
    );
    event ProposalFunded(uint256 id);
    event ProposalRejected(uint256 id);
    event ProposalRemoved(uint256 id);
    event Received(address sender, vitetoken token, uint256 amount);
    event VoteReceived(address member, uint256 proposalId);

    // Receive Token function
    receive() external payable {
        address sender = msg.sender;
        vitetoken token = msg.token;
        uint256 amount = msg.value;

        emit Received(sender, token, amount);
    }

    struct Proposal {
        uint256 id;
        address from;
        address payable to;
        vitetoken token;
        uint256 amount;
        uint256 approvalCount;
        mapping(address => uint256) approvals;
    }

    uint256 public approvalThreshold;
    address[] public members;
    Proposal public proposal;

    constructor(
        address _manager,
        address[] memory _members,
        uint256 _approvalThreshold
    ) payable {
        require(
            _approvalThreshold <= _members.length,
            "approval threshold cannot be larger than number of members"
        );

        members = _members;
        approvalThreshold = _approvalThreshold;

        JointAccountManager manager = JointAccountManager(_manager);
        manager.addJointAccount(address(this));
    }

    function newProposal(
        address payable _to,
        vitetoken _token,
        uint256 _amount
    ) external {
        require(_isMember(), "must be an account member");
        require(balance(_token) >= _amount, "insufficient token balance");

        if (proposal.to != payable(address(0))) {
            emit ProposalRejected(proposal.id);
        }

        proposal.id = proposal.id + 1;
        proposal.from = msg.sender;
        proposal.to = _to;
        proposal.token = _token;
        proposal.amount = _amount;
        proposal.approvalCount = 0;

        emit ProposalCreated(
            proposal.id,
            proposal.from,
            proposal.to,
            proposal.token,
            proposal.amount
        );
    }

    function removeProposal() external {
        require(_isMember(), "must be an account member");
        _removeProposal();
    }

    function approveProposal() external {
        require(_isMember(), "must be an account member");
        require(proposal.to != payable(address(0)));
        require(
            proposal.approvals[msg.sender] != proposal.id,
            "already voted on this proposal"
        );
        require(
            proposal.approvalCount != approvalThreshold,
            "proposal already approved"
        );

        proposal.approvals[msg.sender] = proposal.id;
        proposal.approvalCount = proposal.approvalCount + 1;

        emit VoteReceived(msg.sender, proposal.id);

        if (proposal.approvalCount == approvalThreshold) {
            _fundProposal();
            _removeProposal();
        }
    }

    function _fundProposal() private {
        proposal.to.transfer(proposal.token, proposal.amount);
        emit ProposalFunded(proposal.id);
    }

    function _removeProposal() private {
        proposal.approvalCount = 0;
        proposal.from = payable(address(0));
        proposal.to = payable(address(0));
        proposal.amount = 0;
        proposal.approvalCount = 0;
        emit ProposalRemoved(proposal.id);
    }

    function _isMember() private view returns (bool) {
        for (uint256 i = 0; i < members.length; i++) {
            if (msg.sender == members[i]) {
                return true;
            }
        }
        return false;
    }
}
